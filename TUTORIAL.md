# j2s Tutorial: From JSON to Multi-Language Code

This tutorial walks you through using j2s to generate code in different programming languages from JSON data.

## Table of Contents

1. [Getting Started](#getting-started)
2. [Basic Usage](#basic-usage)
3. [Language-Specific Examples](#language-specific-examples)
4. [Advanced Features](#advanced-features)
5. [Real-World Examples](#real-world-examples)
6. [Integration Workflows](#integration-workflows)

## Getting Started

### Installation

First, build j2s from source:

```bash
git clone https://github.com/echozyr2001/j2s
cd j2s
cargo build --release
```

The binary will be available at `target/release/j2s`.

### Your First Generation

Let's start with a simple JSON file:

```bash
# Create a sample JSON file
cat > person.json << 'EOF'
{
  "name": "Alice Johnson",
  "age": 30,
  "email": "alice@example.com",
  "is_active": true
}
EOF

# Generate Go code
./target/release/j2s person.json --format go --struct-name Person --output person.go
```

This creates a Go struct that looks like:

```go
// Code generated by j2s at 2024-01-15 10:30:00 UTC; DO NOT EDIT.

package main

// Person represents the structure of the JSON data
type Person struct {
    // name (string): Name or title
    Name string `json:"name"`
    // age (int64): Age or numeric value
    Age int64 `json:"age"`
    // email (string): Email address
    Email string `json:"email"`
    // is_active (bool): Boolean flag
    IsActive bool `json:"is_active"`
}
```

## Basic Usage

### Command Structure

```bash
j2s [INPUT_FILE] [OPTIONS]
```

### Common Options

- `--format` or `-f`: Target language (go, rust, typescript, python, schema)
- `--struct-name` or `-s`: Name for the root struct/class/interface
- `--output` or `-o`: Output file path
- `--help`: Show help information

### Format Options

| Format               | Description               | File Extension |
| -------------------- | ------------------------- | -------------- |
| `schema`             | JSON Schema (default)     | `.schema.json` |
| `go`                 | Go structs with JSON tags | `.go`          |
| `rust`               | Rust structs with serde   | `.rs`          |
| `typescript` or `ts` | TypeScript interfaces     | `.ts`          |
| `python` or `py`     | Python dataclasses        | `.py`          |

## Language-Specific Examples

### Go Example

**Input JSON** (`user.json`):

```json
{
  "user_id": 12345,
  "username": "johndoe",
  "profile": {
    "first_name": "John",
    "last_name": "Doe",
    "bio": "Software developer"
  },
  "tags": ["developer", "golang", "backend"]
}
```

**Generate Go code**:

```bash
j2s user.json --format go --struct-name User --output user.go
```

**Generated Go code** (`user.go`):

```go
// Code generated by j2s at 2024-01-15 10:30:00 UTC; DO NOT EDIT.

package main

// User represents the structure of the JSON data
type User struct {
    // user_id (int64): Unique identifier for the user
    UserId int64 `json:"user_id"`
    // username (string): Username or identifier
    Username string `json:"username"`
    // profile (Profile): Profile information
    Profile Profile `json:"profile"`
    // tags ([]string): Array of tag items
    Tags []string `json:"tags"`
}

// Profile represents the structure of the JSON data
type Profile struct {
    // first_name (string): Name or title
    FirstName string `json:"first_name"`
    // last_name (string): Name or title
    LastName string `json:"last_name"`
    // bio (string): Description text
    Bio string `json:"bio"`
}
```

**Using the generated code**:

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
)

func main() {
    jsonData := `{
        "user_id": 12345,
        "username": "johndoe",
        "profile": {
            "first_name": "John",
            "last_name": "Doe",
            "bio": "Software developer"
        },
        "tags": ["developer", "golang", "backend"]
    }`

    var user User
    if err := json.Unmarshal([]byte(jsonData), &user); err != nil {
        log.Fatal(err)
    }

    fmt.Printf("User: %s %s (ID: %d)\n",
        user.Profile.FirstName,
        user.Profile.LastName,
        user.UserId)
    fmt.Printf("Bio: %s\n", user.Profile.Bio)
    fmt.Printf("Tags: %v\n", user.Tags)
}
```

### Rust Example

**Generate Rust code**:

```bash
j2s user.json --format rust --struct-name User --output user.rs
```

**Generated Rust code** (`user.rs`):

```rust
//! Code generated by j2s at 2024-01-15 10:30:00 UTC; DO NOT EDIT.

use serde::{Deserialize, Serialize};

/// User represents the structure of the JSON data
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct User {
    /// user_id (i64): Unique identifier for the user
    pub user_id: i64,
    /// username (String): Username or identifier
    pub username: String,
    /// profile (Profile): Profile information
    pub profile: Profile,
    /// tags (Vec<String>): Array of tag items
    pub tags: Vec<String>,
}

/// Profile represents the structure of the JSON data
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Profile {
    /// first_name (String): Name or title
    pub first_name: String,
    /// last_name (String): Name or title
    pub last_name: String,
    /// bio (String): Description text
    pub bio: String,
}
```

**Using the generated code**:

```rust
use serde_json;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let json_data = r#"{
        "user_id": 12345,
        "username": "johndoe",
        "profile": {
            "first_name": "John",
            "last_name": "Doe",
            "bio": "Software developer"
        },
        "tags": ["developer", "rust", "backend"]
    }"#;

    let user: User = serde_json::from_str(json_data)?;

    println!("User: {} {} (ID: {})",
        user.profile.first_name,
        user.profile.last_name,
        user.user_id);
    println!("Bio: {}", user.profile.bio);
    println!("Tags: {:?}", user.tags);

    Ok(())
}
```

### TypeScript Example

**Generate TypeScript code**:

```bash
j2s user.json --format typescript --struct-name User --output user.ts
```

**Generated TypeScript code** (`user.ts`):

```typescript
/**
 * Code generated by j2s at 2024-01-15 10:30:00 UTC; DO NOT EDIT.
 */

/**
 * User represents the structure of the JSON data
 */
export interface User {
  /** user_id (number): Unique identifier for the user */
  user_id: number;
  /** username (string): Username or identifier */
  username: string;
  /** profile (Profile): Profile information */
  profile: Profile;
  /** tags (string[]): Array of tag items */
  tags: string[];
}

/**
 * Profile represents the structure of the JSON data
 */
export interface Profile {
  /** first_name (string): Name or title */
  first_name: string;
  /** last_name (string): Name or title */
  last_name: string;
  /** bio (string): Description text */
  bio: string;
}
```

**Using the generated code**:

```typescript
import { User } from "./user";

const jsonData = `{
    "user_id": 12345,
    "username": "johndoe",
    "profile": {
        "first_name": "John",
        "last_name": "Doe",
        "bio": "Software developer"
    },
    "tags": ["developer", "typescript", "frontend"]
}`;

const user: User = JSON.parse(jsonData) as User;

console.log(
  `User: ${user.profile.first_name} ${user.profile.last_name} (ID: ${user.user_id})`
);
console.log(`Bio: ${user.profile.bio}`);
console.log(`Tags: ${user.tags.join(", ")}`);

// Type-safe access
const fullName = `${user.profile.first_name} ${user.profile.last_name}`;
const tagCount = user.tags.length;
```

### Python Example

**Generate Python code**:

```bash
j2s user.json --format python --struct-name User --output user.py
```

**Generated Python code** (`user.py`):

```python
"""
Code generated by j2s at 2024-01-15 10:30:00 UTC; DO NOT EDIT.
This file was automatically generated from JSON data.
"""

from dataclasses import dataclass
from typing import List

@dataclass
class Profile:
    """Profile represents the structure of the JSON data"""
    first_name: str  # first_name (str): Name or title
    last_name: str  # last_name (str): Name or title
    bio: str  # bio (str): Description text

@dataclass
class User:
    """User represents the structure of the JSON data"""
    user_id: int  # user_id (int): Unique identifier for the user
    username: str  # username (str): Username or identifier
    profile: Profile  # profile (Profile): Profile information
    tags: List[str]  # tags (List[str]): Array of tag items
```

**Using the generated code**:

```python
import json
from user import User, Profile

json_data = """{
    "user_id": 12345,
    "username": "johndoe",
    "profile": {
        "first_name": "John",
        "last_name": "Doe",
        "bio": "Software developer"
    },
    "tags": ["developer", "python", "backend"]
}"""

data = json.loads(json_data)

# Create nested objects
profile = Profile(**data['profile'])
user = User(
    user_id=data['user_id'],
    username=data['username'],
    profile=profile,
    tags=data['tags']
)

print(f"User: {user.profile.first_name} {user.profile.last_name} (ID: {user.user_id})")
print(f"Bio: {user.profile.bio}")
print(f"Tags: {', '.join(user.tags)}")
```

## Advanced Features

### Handling Optional Fields

**Input JSON with optional fields**:

```json
{
  "id": 1,
  "name": "Product",
  "description": null,
  "price": 99.99,
  "category": "electronics"
}
```

**Generated code handles nulls appropriately**:

- **Go**: Uses pointers (`*string`)
- **Rust**: Uses `Option<T>`
- **TypeScript**: Uses union types (`string | null`)
- **Python**: Uses `Optional[T]`

### Complex Nested Structures

**Input JSON** (`api_response.json`):

```json
{
  "status": "success",
  "data": {
    "users": [
      {
        "id": 1,
        "name": "Alice",
        "permissions": ["read", "write"]
      }
    ],
    "pagination": {
      "page": 1,
      "total": 100
    }
  }
}
```

**Generate for all languages**:

```bash
j2s api_response.json --format go --struct-name ApiResponse --output api_response.go
j2s api_response.json --format rust --struct-name ApiResponse --output api_response.rs
j2s api_response.json --format typescript --struct-name ApiResponse --output api_response.ts
j2s api_response.json --format python --struct-name ApiResponse --output api_response.py
```

### Mixed Type Arrays

j2s handles arrays with different element types by creating appropriate union types or generic containers.

## Real-World Examples

### E-commerce Product Catalog

**Scenario**: You have a product catalog API that returns complex product data.

**Input** (`product_catalog.json`):

```json
{
  "products": [
    {
      "id": "PROD-001",
      "name": "Wireless Headphones",
      "price": 199.99,
      "currency": "USD",
      "in_stock": true,
      "categories": ["electronics", "audio"],
      "specifications": {
        "brand": "TechCorp",
        "model": "WH-1000",
        "features": ["noise-canceling", "bluetooth", "wireless"]
      },
      "reviews": {
        "average_rating": 4.5,
        "total_count": 1247
      }
    }
  ],
  "metadata": {
    "total_products": 1,
    "page": 1,
    "per_page": 10
  }
}
```

**Generate code**:

```bash
j2s product_catalog.json --format go --struct-name ProductCatalog --output models/catalog.go
j2s product_catalog.json --format typescript --struct-name ProductCatalog --output types/catalog.ts
```

### User Authentication Response

**Input** (`auth_response.json`):

```json
{
  "success": true,
  "user": {
    "id": 12345,
    "email": "user@example.com",
    "roles": ["user", "premium"],
    "profile": {
      "display_name": "John Doe",
      "avatar_url": "https://example.com/avatar.jpg",
      "preferences": {
        "theme": "dark",
        "notifications": true
      }
    }
  },
  "tokens": {
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    "expires_in": 3600
  }
}
```

**Usage in different languages**:

```bash
# Generate for backend (Go/Rust)
j2s auth_response.json --format go --struct-name AuthResponse --output auth.go
j2s auth_response.json --format rust --struct-name AuthResponse --output auth.rs

# Generate for frontend (TypeScript)
j2s auth_response.json --format typescript --struct-name AuthResponse --output auth.ts
```

## Integration Workflows

### Development Workflow

1. **Design your JSON structure**
2. **Create sample JSON files**
3. **Generate code for all target languages**
4. **Write tests using generated types**
5. **Integrate into your applications**

### CI/CD Integration

**GitHub Actions example** (`.github/workflows/codegen.yml`):

```yaml
name: Generate Code from JSON

on:
  push:
    paths:
      - "schemas/*.json"
  pull_request:
    paths:
      - "schemas/*.json"

jobs:
  generate:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Build j2s
        run: cargo build --release

      - name: Generate Go models
        run: |
          mkdir -p generated/go
          for file in schemas/*.json; do
            base=$(basename "$file" .json)
            ./target/release/j2s "$file" --format go --struct-name "${base^}" --output "generated/go/${base}.go"
          done

      - name: Generate TypeScript types
        run: |
          mkdir -p generated/typescript
          for file in schemas/*.json; do
            base=$(basename "$file" .json)
            ./target/release/j2s "$file" --format typescript --struct-name "${base^}" --output "generated/typescript/${base}.ts"
          done

      - name: Commit generated code
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add generated/
          git diff --staged --quiet || git commit -m "Update generated code"
          git push
```

### Makefile Integration

**Makefile**:

```makefile
.PHONY: generate-all generate-go generate-rust generate-ts generate-py clean

SCHEMAS := $(wildcard schemas/*.json)
J2S := ./target/release/j2s

# Build j2s if not exists
$(J2S):
	cargo build --release

generate-all: generate-go generate-rust generate-ts generate-py

generate-go: $(J2S)
	@mkdir -p generated/go
	@for schema in $(SCHEMAS); do \
		base=$$(basename $$schema .json); \
		echo "Generating Go code for $$base..."; \
		$(J2S) $$schema --format go --struct-name "$${base^}" --output "generated/go/$$base.go"; \
	done

generate-rust: $(J2S)
	@mkdir -p generated/rust
	@for schema in $(SCHEMAS); do \
		base=$$(basename $$schema .json); \
		echo "Generating Rust code for $$base..."; \
		$(J2S) $$schema --format rust --struct-name "$${base^}" --output "generated/rust/$$base.rs"; \
	done

generate-ts: $(J2S)
	@mkdir -p generated/typescript
	@for schema in $(SCHEMAS); do \
		base=$$(basename $$schema .json); \
		echo "Generating TypeScript code for $$base..."; \
		$(J2S) $$schema --format typescript --struct-name "$${base^}" --output "generated/typescript/$$base.ts"; \
	done

generate-py: $(J2S)
	@mkdir -p generated/python
	@for schema in $(SCHEMAS); do \
		base=$$(basename $$schema .json); \
		echo "Generating Python code for $$base..."; \
		$(J2S) $$schema --format python --struct-name "$${base^}" --output "generated/python/$$base.py"; \
	done

clean:
	rm -rf generated/

test-generated:
	@echo "Testing generated Go code..."
	@cd generated/go && go mod init test && go mod tidy && go build ./...

	@echo "Testing generated Rust code..."
	@cd generated/rust && cargo init --name test && cargo check

	@echo "Testing generated TypeScript code..."
	@cd generated/typescript && npx tsc --noEmit *.ts
```

### Docker Integration

**Dockerfile**:

```dockerfile
FROM rust:1.70 as builder

WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bullseye-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/j2s /usr/local/bin/j2s

WORKDIR /workspace

ENTRYPOINT ["j2s"]
```

**Usage**:

```bash
# Build the image
docker build -t j2s .

# Use it to generate code
docker run --rm -v $(pwd):/workspace j2s data.json --format go --output output.go
```

## Tips and Tricks

### 1. Batch Processing

```bash
# Process all JSON files in a directory
for file in data/*.json; do
    base=$(basename "$file" .json)
    j2s "$file" --format go --struct-name "${base^}Data" --output "models/${base}.go"
done
```

### 2. Validation

```bash
# Validate JSON before processing
jq empty data.json && j2s data.json --format go
```

### 3. Combining with jq

```bash
# Extract subset of large JSON
jq '.users[0]' large_api_response.json > user_sample.json
j2s user_sample.json --format typescript --struct-name User
```

### 4. Template Generation

```bash
# Generate templates for all languages
languages=("go" "rust" "typescript" "python")
for lang in "${languages[@]}"; do
    j2s template.json --format "$lang" --struct-name Template --output "template.$lang"
done
```

This tutorial should give you a comprehensive understanding of how to use j2s effectively in your development workflow. Experiment with different JSON structures and see how j2s generates appropriate code for each language!
