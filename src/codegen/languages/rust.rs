//! # Rust Language Code Generator
//!
//! This module implements the code generator for the Rust programming language.
//! It generates Rust structs with appropriate serde annotations, type mappings, and
//! follows Rust naming conventions and best practices.

use crate::codegen::comments::RustCommentGenerator;
use crate::codegen::generator::{CodeGenerator, GenerationOptions};
use crate::codegen::types::{FieldDefinition, FieldType, StructDefinition};
use crate::codegen::utils::{NameConverter, escape_comment_string, generate_timestamp};
use crate::error::Result;
use serde_json::Value;
use std::collections::HashSet;

/// Rust language code generator
///
/// This generator creates Rust struct definitions from JSON data, including:
/// - Proper Rust naming conventions (PascalCase for types, snake_case for fields)
/// - Serde derive macros for serialization/deserialization
/// - Option<T> types for optional fields
/// - Appropriate type mappings for Rust's type system
pub struct RustGenerator {
    /// Rust reserved keywords that need to be avoided in generated identifiers
    keywords: HashSet<String>,
    /// Comment generator for Rust-specific comments
    comment_generator: RustCommentGenerator,
}

impl RustGenerator {
    /// Create a new Rust code generator
    pub fn new() -> Self {
        let mut keywords = HashSet::new();
        
        // Add Rust reserved keywords
        let rust_keywords = [
            "as", "break", "const", "continue", "crate", "else", "enum", "extern",
            "false", "fn", "for", "if", "impl", "in", "let", "loop", "match",
            "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static",
            "struct", "super", "trait", "true", "type", "unsafe", "use", "where",
            "while", "async", "await", "dyn", "abstract", "become", "box", "do",
            "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
            "yield", "try", "union", "raw",
        ];
        
        for keyword in &rust_keywords {
            keywords.insert(keyword.to_string());
        }
        
        Self { 
            keywords,
            comment_generator: RustCommentGenerator,
        }
    }

    /// Map a FieldType to the appropriate Rust type string
    fn map_field_type(&self, field_type: &FieldType, is_optional: bool, is_array: bool) -> String {
        let base_type = match field_type {
            FieldType::String => "String",
            FieldType::Integer => "i64",
            FieldType::Number => "f64",
            FieldType::Boolean => "bool",
            FieldType::Custom(name) => name,
            FieldType::Any => {
                if is_array {
                    // For arrays with mixed types, use serde_json::Value as element type
                    "serde_json::Value"
                } else {
                    // For single Any fields, use serde_json::Value
                    "serde_json::Value"
                }
            }
        };

        let mut result = base_type.to_string();

        // Handle arrays
        if is_array {
            result = format!("Vec<{result}>");
        }

        // Handle optional fields with Option<T>
        if is_optional {
            result = format!("Option<{result}>");
        }

        result
    }

    /// Generate a Rust struct field declaration
    fn generate_field(&self, field: &FieldDefinition) -> String {
        // The code_name is already converted to the proper case by JsonToIrConverter
        let sanitized_name = NameConverter::sanitize_identifier(&field.code_name, &self.keywords);
        
        let field_type = self.map_field_type(&field.field_type, field.is_optional, field.is_array);
        
        // Add comments if present
        let mut result = String::new();
        for comment in &field.comments {
            let escaped_comment = escape_comment_string(comment);
            result.push_str(&format!("    /// {escaped_comment}\n"));
        }

        // Generate serde annotation if field name differs from JSON name
        if field.json_name != field.code_name {
            if field.is_optional {
                result.push_str(&format!("    #[serde(rename = \"{}\", skip_serializing_if = \"Option::is_none\")]\n", field.json_name));
            } else {
                result.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.json_name));
            }
        } else if field.is_optional {
            result.push_str("    #[serde(skip_serializing_if = \"Option::is_none\")]\n");
        }

        result.push_str(&format!("    pub {sanitized_name}: {field_type},"));
        result
    }

    /// Generate file header with generation information
    fn generate_file_header(&self) -> String {
        let timestamp = generate_timestamp();
        format!(
            "// Code generated by j2s (JSON to Struct) tool\n// Generated at: {timestamp}\n// DO NOT EDIT - This file was automatically generated\n\n"
        )
    }

    /// Generate derive macros for the struct
    fn generate_derives(&self, options: &GenerationOptions) -> String {
        let mut derives = vec!["Serialize", "Deserialize"];
        
        // Add common derives based on options
        if options.get_language_option("derive_debug").unwrap_or(&"true".to_string()) == "true" {
            derives.push("Debug");
        }
        if options.get_language_option("derive_clone").unwrap_or(&"true".to_string()) == "true" {
            derives.push("Clone");
        }
        if options.get_language_option("derive_partial_eq").unwrap_or(&"false".to_string()) == "true" {
            derives.push("PartialEq");
        }
        
        format!("#[derive({})]\n", derives.join(", "))
    }

    /// Generate use statements
    fn generate_use_statements(&self) -> String {
        "use serde::{Deserialize, Serialize};\n\n".to_string()
    }

    /// Generate a complete Rust struct definition
    fn generate_struct(&self, struct_def: &StructDefinition, options: &GenerationOptions) -> String {
        let struct_name = NameConverter::to_pascal_case(&struct_def.name);
        let sanitized_name = NameConverter::sanitize_identifier(&struct_name, &self.keywords);

        let mut result = String::new();

        // Add struct comments
        for comment in &struct_def.comments {
            let escaped_comment = escape_comment_string(comment);
            result.push_str(&format!("/// {escaped_comment}\n"));
        }

        // Add derive macros
        result.push_str(&self.generate_derives(options));

        // Start struct definition
        result.push_str(&format!("pub struct {sanitized_name} {{\n"));

        // Add fields
        for field in &struct_def.fields {
            result.push_str(&self.generate_field(field));
            result.push('\n');
        }

        // Close struct definition
        result.push_str("}\n");

        result
    }
}

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGenerator for RustGenerator {
    fn generate(&self, json_value: &Value, options: &GenerationOptions) -> Result<String> {
        use crate::codegen::types::JsonToIrConverter;
        
        // Create converter for Rust language
        let mut converter = JsonToIrConverter::new("rust");
        
        // Determine struct name
        let struct_name = options.get_struct_name("GeneratedStruct");
        let sanitized_struct_name = NameConverter::convert_type_name(&struct_name, "rust");
        
        // Convert JSON to intermediate representation
        let struct_def = converter.convert_to_struct(json_value, &sanitized_struct_name)?;
        
        // Generate Rust code
        let mut result = String::new();
        
        // Add file header comment if comments are enabled
        if options.include_comments {
            result.push_str(&self.generate_file_header());
        }
        
        // Add use statements
        result.push_str(&self.generate_use_statements());
        
        // Generate nested structs first
        for nested_struct in &struct_def.nested_structs {
            result.push_str(&self.generate_struct(nested_struct, options));
            result.push('\n');
        }
        
        // Generate main struct
        result.push_str(&self.generate_struct(&struct_def, options));
        
        Ok(result)
    }

    fn file_extension(&self) -> &'static str {
        "rs"
    }

    fn language_name(&self) -> &'static str {
        "Rust"
    }

    fn validate_options(&self, _options: &GenerationOptions) -> Result<()> {
        // Basic validation - can be extended later
        Ok(())
    }
}
#
[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::types::FieldType;

    #[test]
    fn test_rust_generator_creation() {
        let generator = RustGenerator::new();
        assert_eq!(generator.language_name(), "Rust");
        assert_eq!(generator.file_extension(), "rs");
    }

    #[test]
    fn test_map_field_type() {
        let generator = RustGenerator::new();
        
        assert_eq!(generator.map_field_type(&FieldType::String, false, false), "String");
        assert_eq!(generator.map_field_type(&FieldType::Integer, false, false), "i64");
        assert_eq!(generator.map_field_type(&FieldType::Number, false, false), "f64");
        assert_eq!(generator.map_field_type(&FieldType::Boolean, false, false), "bool");
        assert_eq!(generator.map_field_type(&FieldType::Any, false, false), "serde_json::Value");
        
        // Test optional types
        assert_eq!(generator.map_field_type(&FieldType::String, true, false), "Option<String>");
        assert_eq!(generator.map_field_type(&FieldType::Integer, true, false), "Option<i64>");
        
        // Test array types
        assert_eq!(generator.map_field_type(&FieldType::String, false, true), "Vec<String>");
        assert_eq!(generator.map_field_type(&FieldType::Integer, false, true), "Vec<i64>");
        
        // Test optional array types
        assert_eq!(generator.map_field_type(&FieldType::String, true, true), "Option<Vec<String>>");
    }

    #[test]
    fn test_generate_field() {
        let generator = RustGenerator::new();
        
        // The code_name should already be converted to Rust naming convention
        let field = FieldDefinition::new("user_name", "user_name", FieldType::String)
            .add_comment("The user's name");
        
        let result = generator.generate_field(&field);
        assert!(result.contains("pub user_name: String,"));
        assert!(result.contains("/// The user's name"));
    }

    #[test]
    fn test_generate_field_optional() {
        let generator = RustGenerator::new();
        
        // The code_name should already be converted to Rust naming convention
        let field = FieldDefinition::new("email", "email", FieldType::String)
            .optional(true);
        
        let result = generator.generate_field(&field);
        assert!(result.contains("pub email: Option<String>,"));
        assert!(result.contains("#[serde(skip_serializing_if = \"Option::is_none\")]"));
    }

    #[test]
    fn test_generate_field_array() {
        let generator = RustGenerator::new();
        
        // The code_name should already be converted to Rust naming convention
        let field = FieldDefinition::new("tags", "tags", FieldType::String)
            .array(true);
        
        let result = generator.generate_field(&field);
        assert!(result.contains("pub tags: Vec<String>,"));
    }

    #[test]
    fn test_generate_field_with_rename() {
        let generator = RustGenerator::new();
        
        // Field with different JSON name and code name
        let field = FieldDefinition::new("user_name", "user_name", FieldType::String);
        
        let result = generator.generate_field(&field);
        // Since JSON name and code name are the same, no rename should be generated
        assert!(!result.contains("#[serde(rename"));
        
        // Test with different names
        let field = FieldDefinition::new("userName", "user_name", FieldType::String);
        let result = generator.generate_field(&field);
        assert!(result.contains("#[serde(rename = \"userName\")]"));
    }

    #[test]
    fn test_generate_derives() {
        let generator = RustGenerator::new();
        let options = GenerationOptions::default();
        
        let result = generator.generate_derives(&options);
        assert!(result.contains("#[derive("));
        assert!(result.contains("Serialize"));
        assert!(result.contains("Deserialize"));
        assert!(result.contains("Debug"));
        assert!(result.contains("Clone"));
    }

    #[test]
    fn test_generate_derives_custom() {
        let generator = RustGenerator::new();
        let options = GenerationOptions::default()
            .with_language_option("derive_debug", "false")
            .with_language_option("derive_partial_eq", "true");
        
        let result = generator.generate_derives(&options);
        assert!(result.contains("Serialize"));
        assert!(result.contains("Deserialize"));
        assert!(!result.contains("Debug"));
        assert!(result.contains("Clone"));
        assert!(result.contains("PartialEq"));
    }

    #[test]
    fn test_generate_struct() {
        let generator = RustGenerator::new();
        let options = GenerationOptions::default();
        
        // The code_name should already be converted to Rust naming convention
        let field1 = FieldDefinition::new("id", "id", FieldType::Integer);
        let field2 = FieldDefinition::new("name", "name", FieldType::String);
        
        let struct_def = StructDefinition::new("User")
            .add_field(field1)
            .add_field(field2)
            .add_comment("User represents a user in the system");
        
        let result = generator.generate_struct(&struct_def, &options);
        assert!(result.contains("pub struct User {"));
        assert!(result.contains("pub id: i64,"));
        assert!(result.contains("pub name: String,"));
        assert!(result.contains("/// User represents a user in the system"));
        assert!(result.contains("#[derive("));
        assert!(result.ends_with("}\n"));
    }

    #[test]
    fn test_keyword_sanitization() {
        let generator = RustGenerator::new();
        
        // The code_name should already be converted and sanitized
        let field = FieldDefinition::new("type", "type_", FieldType::String);
        let result = generator.generate_field(&field);
        
        // Should be sanitized to avoid Rust keyword conflict
        assert!(result.contains("pub type_: String,"));
    }

    #[test]
    fn test_validate_options() {
        let generator = RustGenerator::new();
        let options = GenerationOptions::default();
        
        assert!(generator.validate_options(&options).is_ok());
    }

    #[test]
    fn test_generate_simple_struct() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "name": "John Doe",
            "age": 30,
            "is_active": true
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("User")
            .with_comments(true);
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("use serde::{Deserialize, Serialize};"));
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub name: String,"));
        assert!(code.contains("pub age: i64,"));
        assert!(code.contains("pub is_active: bool,"));
        assert!(code.contains("#[derive("));
    }

    #[test]
    fn test_generate_with_optional_fields() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "name": "John Doe",
            "email": null,
            "age": 30
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("User")
            .with_optional_fields(true);
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("pub name: String,"));
        assert!(code.contains("pub age: i64,"));
        // Email should be optional since it was null in JSON
        assert!(code.contains("pub email: Option<"));
        assert!(code.contains("#[serde(skip_serializing_if = \"Option::is_none\")]"));
    }

    #[test]
    fn test_generate_with_arrays() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "name": "John Doe",
            "tags": ["developer", "rust", "go"],
            "scores": [95, 87, 92]
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("User");
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("pub tags: Vec<String>,"));
        assert!(code.contains("pub scores: Vec<i64>,"));
    }

    #[test]
    fn test_generate_use_statements() {
        let generator = RustGenerator::new();
        let result = generator.generate_use_statements();
        
        assert!(result.contains("use serde::{Deserialize, Serialize};"));
    }
}    #
[test]
    fn test_generate_nested_structs() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "user": {
                "name": "John Doe",
                "age": 30
            },
            "company": "Acme Corp"
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("Response");
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        // Should generate nested struct for user
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub struct Response"));
        assert!(code.contains("pub user: User,"));
        assert!(code.contains("pub company: String,"));
    }

    #[test]
    fn test_generate_with_custom_derives() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "name": "test"
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("Test")
            .with_language_option("derive_debug", "false")
            .with_language_option("derive_partial_eq", "true");
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("Serialize"));
        assert!(code.contains("Deserialize"));
        assert!(!code.contains("Debug"));
        assert!(code.contains("PartialEq"));
    }

    #[test]
    fn test_generate_complex_json() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "id": 123,
            "name": "John Doe",
            "email": null,
            "tags": ["rust", "developer"],
            "profile": {
                "bio": "Software developer",
                "location": "San Francisco",
                "skills": ["Rust", "Go", "Python"]
            },
            "scores": [95, 87, 92],
            "is_active": true
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("User")
            .with_comments(true);
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        
        // Check main struct
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub id: i64,"));
        assert!(code.contains("pub name: String,"));
        assert!(code.contains("pub email: Option<"));
        assert!(code.contains("pub tags: Vec<String>,"));
        assert!(code.contains("pub profile: Profile,"));
        assert!(code.contains("pub scores: Vec<i64>,"));
        assert!(code.contains("pub is_active: bool,"));
        
        // Check nested struct
        assert!(code.contains("pub struct Profile"));
        assert!(code.contains("pub bio: String,"));
        assert!(code.contains("pub location: String,"));
        assert!(code.contains("pub skills: Vec<String>,"));
        
        // Check serde annotations
        assert!(code.contains("#[serde(skip_serializing_if = \"Option::is_none\")]"));
        
        // Check derives
        assert!(code.contains("#[derive("));
        assert!(code.contains("Serialize"));
        assert!(code.contains("Deserialize"));
        
        // Check use statements
        assert!(code.contains("use serde::{Deserialize, Serialize};"));
        
        // Check file header
        assert!(code.contains("// Code generated by j2s"));
    }

    #[test]
    fn test_rust_type_mappings() {
        let generator = RustGenerator::new();
        
        // Test all basic type mappings
        assert_eq!(generator.map_field_type(&FieldType::String, false, false), "String");
        assert_eq!(generator.map_field_type(&FieldType::Integer, false, false), "i64");
        assert_eq!(generator.map_field_type(&FieldType::Number, false, false), "f64");
        assert_eq!(generator.map_field_type(&FieldType::Boolean, false, false), "bool");
        assert_eq!(generator.map_field_type(&FieldType::Any, false, false), "serde_json::Value");
        
        // Test custom types
        let custom_type = FieldType::Custom("CustomStruct".to_string());
        assert_eq!(generator.map_field_type(&custom_type, false, false), "CustomStruct");
        assert_eq!(generator.map_field_type(&custom_type, true, false), "Option<CustomStruct>");
        assert_eq!(generator.map_field_type(&custom_type, false, true), "Vec<CustomStruct>");
        assert_eq!(generator.map_field_type(&custom_type, true, true), "Option<Vec<CustomStruct>>");
    }

    #[test]
    fn test_serde_annotations() {
        let generator = RustGenerator::new();
        
        // Test field with same JSON and code name (no rename needed)
        let field1 = FieldDefinition::new("name", "name", FieldType::String);
        let result1 = generator.generate_field(&field1);
        assert!(!result1.contains("#[serde(rename"));
        
        // Test optional field with same names
        let field2 = FieldDefinition::new("email", "email", FieldType::String).optional(true);
        let result2 = generator.generate_field(&field2);
        assert!(result2.contains("#[serde(skip_serializing_if = \"Option::is_none\")]"));
        assert!(!result2.contains("#[serde(rename"));
        
        // Test field with different JSON and code names
        let field3 = FieldDefinition::new("user_name", "user_name", FieldType::String);
        let result3 = generator.generate_field(&field3);
        // Since they're the same, no rename should be generated
        assert!(!result3.contains("#[serde(rename"));
        
        // Test field with different names and optional
        let field4 = FieldDefinition::new("firstName", "first_name", FieldType::String).optional(true);
        let result4 = generator.generate_field(&field4);
        assert!(result4.contains("#[serde(rename = \"firstName\", skip_serializing_if = \"Option::is_none\")]"));
    }  
  #[test]
    fn test_debug_complex_json() {
        use serde_json::json;
        
        let generator = RustGenerator::new();
        let json_data = json!({
            "profile": {
                "bio": "Software developer",
                "location": "San Francisco"
            }
        });
        
        let options = GenerationOptions::default()
            .with_struct_name("User");
        
        let result = generator.generate(&json_data, &options);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        println!("Generated code:\n{}", code);
        
        // This test is just for debugging - it will always pass
        assert!(true);
    }