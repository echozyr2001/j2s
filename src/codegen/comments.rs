//! # Comment Generation System
//!
//! This module provides a unified interface for generating comments and documentation
//! in different programming languages. It supports language-specific comment formats
//! and includes functionality for file headers, field descriptions, and metadata.

use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Trait for generating language-specific comments
pub trait CommentGenerator {
    /// Generate a file header comment with tool information and generation time
    fn generate_file_header(&self, tool_name: &str, generation_time: &DateTime<Utc>) -> String;
    
    /// Generate a comment for a struct/class/interface
    fn generate_struct_comment(&self, struct_name: &str, description: Option<&str>) -> String;
    
    /// Generate a comment for a field/property
    fn generate_field_comment(&self, field_name: &str, field_type: &str, description: Option<&str>) -> String;
    
    /// Generate a single-line comment
    fn generate_single_line_comment(&self, text: &str) -> String;
    
    /// Generate a multi-line comment
    fn generate_multi_line_comment(&self, lines: &[&str]) -> String;
    
    /// Get the language name for this comment generator
    fn language_name(&self) -> &'static str;
}

/// Go language comment generator
pub struct GoCommentGenerator;

impl CommentGenerator for GoCommentGenerator {
    fn generate_file_header(&self, tool_name: &str, generation_time: &DateTime<Utc>) -> String {
        format!(
            "// Code generated by {} at {}; DO NOT EDIT.\n// This file was automatically generated from JSON data.\n",
            tool_name,
            generation_time.format("%Y-%m-%d %H:%M:%S UTC")
        )
    }
    
    fn generate_struct_comment(&self, struct_name: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("// {} {}\n", struct_name, desc),
            None => format!("// {} represents the structure of the JSON data\n", struct_name),
        }
    }
    
    fn generate_field_comment(&self, field_name: &str, field_type: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("\t// {} ({}): {}\n", field_name, field_type, desc),
            None => format!("\t// {} is of type {}\n", field_name, field_type),
        }
    }
    
    fn generate_single_line_comment(&self, text: &str) -> String {
        format!("// {}\n", text)
    }
    
    fn generate_multi_line_comment(&self, lines: &[&str]) -> String {
        lines.iter()
            .map(|line| format!("// {}\n", line))
            .collect::<String>()
    }
    
    fn language_name(&self) -> &'static str {
        "Go"
    }
}

/// Rust language comment generator
pub struct RustCommentGenerator;

impl CommentGenerator for RustCommentGenerator {
    fn generate_file_header(&self, tool_name: &str, generation_time: &DateTime<Utc>) -> String {
        format!(
            "//! Code generated by {} at {}; DO NOT EDIT.\n//! This file was automatically generated from JSON data.\n\n",
            tool_name,
            generation_time.format("%Y-%m-%d %H:%M:%S UTC")
        )
    }
    
    fn generate_struct_comment(&self, struct_name: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("/// {} - {}\n", struct_name, desc),
            None => format!("/// {} represents the structure of the JSON data\n", struct_name),
        }
    }
    
    fn generate_field_comment(&self, field_name: &str, field_type: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("    /// {} ({}): {}\n", field_name, field_type, desc),
            None => format!("    /// {} is of type {}\n", field_name, field_type),
        }
    }
    
    fn generate_single_line_comment(&self, text: &str) -> String {
        format!("/// {}\n", text)
    }
    
    fn generate_multi_line_comment(&self, lines: &[&str]) -> String {
        lines.iter()
            .map(|line| format!("/// {}\n", line))
            .collect::<String>()
    }
    
    fn language_name(&self) -> &'static str {
        "Rust"
    }
}

/// TypeScript language comment generator
pub struct TypeScriptCommentGenerator;

impl CommentGenerator for TypeScriptCommentGenerator {
    fn generate_file_header(&self, tool_name: &str, generation_time: &DateTime<Utc>) -> String {
        format!(
            "/**\n * Code generated by {} at {}; DO NOT EDIT.\n * This file was automatically generated from JSON data.\n */\n\n",
            tool_name,
            generation_time.format("%Y-%m-%d %H:%M:%S UTC")
        )
    }
    
    fn generate_struct_comment(&self, struct_name: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("/**\n * {} - {}\n */\n", struct_name, desc),
            None => format!("/**\n * {} represents the structure of the JSON data\n */\n", struct_name),
        }
    }
    
    fn generate_field_comment(&self, field_name: &str, field_type: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("  /** {} ({}): {} */\n", field_name, field_type, desc),
            None => format!("  /** {} is of type {} */\n", field_name, field_type),
        }
    }
    
    fn generate_single_line_comment(&self, text: &str) -> String {
        format!("// {}\n", text)
    }
    
    fn generate_multi_line_comment(&self, lines: &[&str]) -> String {
        let mut result = String::from("/**\n");
        for line in lines {
            result.push_str(&format!(" * {}\n", line));
        }
        result.push_str(" */\n");
        result
    }
    
    fn language_name(&self) -> &'static str {
        "TypeScript"
    }
}

/// Python language comment generator
pub struct PythonCommentGenerator;

impl CommentGenerator for PythonCommentGenerator {
    fn generate_file_header(&self, tool_name: &str, generation_time: &DateTime<Utc>) -> String {
        format!(
            "\"\"\"Code generated by {} at {}; DO NOT EDIT.\nThis file was automatically generated from JSON data.\n\"\"\"\n\n",
            tool_name,
            generation_time.format("%Y-%m-%d %H:%M:%S UTC")
        )
    }
    
    fn generate_struct_comment(&self, struct_name: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("    \"\"\"{} - {}\"\"\"\n", struct_name, desc),
            None => format!("    \"\"\"{}.\n    \n    Represents the structure of the JSON data.\n    \"\"\"\n", struct_name),
        }
    }
    
    fn generate_field_comment(&self, field_name: &str, field_type: &str, description: Option<&str>) -> String {
        match description {
            Some(desc) => format!("    # {} ({}): {}\n", field_name, field_type, desc),
            None => format!("    # {} is of type {}\n", field_name, field_type),
        }
    }
    
    fn generate_single_line_comment(&self, text: &str) -> String {
        format!("# {}\n", text)
    }
    
    fn generate_multi_line_comment(&self, lines: &[&str]) -> String {
        let content = lines.join("\n");
        format!("\"\"\"{}\n\"\"\"\n", content)
    }
    
    fn language_name(&self) -> &'static str {
        "Python"
    }
}

/// Factory for creating comment generators
pub struct CommentGeneratorFactory;

impl CommentGeneratorFactory {
    /// Create a comment generator for the specified language
    pub fn create_generator(language: &str) -> Box<dyn CommentGenerator> {
        match language.to_lowercase().as_str() {
            "go" => Box::new(GoCommentGenerator),
            "rust" => Box::new(RustCommentGenerator),
            "typescript" | "ts" => Box::new(TypeScriptCommentGenerator),
            "python" | "py" => Box::new(PythonCommentGenerator),
            _ => Box::new(GoCommentGenerator), // Default fallback
        }
    }
    
    /// Get all supported languages
    pub fn supported_languages() -> Vec<&'static str> {
        vec!["go", "rust", "typescript", "python"]
    }
}

/// Utility functions for comment processing
pub mod utils {
    /// Escape special characters in comment text to prevent comment injection
    pub fn escape_comment_text(text: &str) -> String {
        text.replace("*/", "* /")
            .replace("<!--", "&lt;!--")
            .replace("-->", "--&gt;")
    }
    
    /// Generate a description for a field based on its JSON name and inferred type
    pub fn infer_field_description(json_name: &str, field_type: &str) -> String {
        // Enhanced heuristics for generating field descriptions
        let name = json_name.to_lowercase();
        
        // Check for common patterns in field names
        match name.as_str() {
            // Exact matches first
            "id" => "Unique identifier".to_string(),
            "name" | "title" => "Name or title".to_string(),
            "email" => "Email address".to_string(),
            "phone" | "telephone" => "Phone number".to_string(),
            "address" => "Address information".to_string(),
            "url" | "link" | "href" => "URL or link".to_string(),
            "date" | "time" | "timestamp" => "Date/time value".to_string(),
            "status" => "Status indicator".to_string(),
            "type" | "kind" => "Type classification".to_string(),
            "count" | "total" | "amount" => "Count or total value".to_string(),
            "description" | "desc" => "Description text".to_string(),
            "value" => "Value".to_string(),
            "key" => "Key identifier".to_string(),
            "code" => "Code value".to_string(),
            "version" => "Version information".to_string(),
            "enabled" | "active" | "visible" => "Boolean flag".to_string(),
            
            // Pattern matches
            _ => {
                // ID patterns
                if name.ends_with("_id") || name.ends_with("id") {
                    let base_name = name.replace("_id", "").replace("id", "");
                    if base_name.is_empty() {
                        "Unique identifier".to_string()
                    } else {
                        format!("Unique identifier for the {}", base_name.replace('_', " "))
                    }
                }
                // Name patterns
                else if name.contains("name") || name.contains("title") {
                    "Name or title".to_string()
                }
                // Email patterns
                else if name.contains("email") || name.contains("mail") {
                    "Email address".to_string()
                }
                // Phone patterns
                else if name.contains("phone") || name.contains("tel") || name.contains("mobile") {
                    "Phone number".to_string()
                }
                // Address patterns
                else if name.contains("address") || name.contains("location") {
                    "Address information".to_string()
                }
                // Date/time patterns
                else if name.contains("date") || name.contains("time") || name.contains("created") || 
                        name.contains("updated") || name.contains("modified") || name.contains("timestamp") {
                    "Date/time value".to_string()
                }
                // URL patterns
                else if name.contains("url") || name.contains("link") || name.contains("href") || 
                        name.contains("uri") || name.contains("endpoint") {
                    "URL or link".to_string()
                }
                // Count patterns
                else if name.contains("count") || name.contains("total") || name.contains("num") || 
                        name.contains("amount") || name.contains("quantity") {
                    "Count or total value".to_string()
                }
                // Status patterns
                else if name.contains("status") || name.contains("state") {
                    "Status indicator".to_string()
                }
                // Type patterns
                else if name.contains("type") || name.contains("kind") || name.contains("category") {
                    "Type classification".to_string()
                }
                // Description patterns
                else if name.contains("desc") || name.contains("comment") || name.contains("note") {
                    "Description text".to_string()
                }
                // Boolean patterns
                else if name.starts_with("is_") || name.starts_with("has_") || name.starts_with("can_") ||
                        name.starts_with("should_") || name.starts_with("will_") || name.contains("enabled") ||
                        name.contains("active") || name.contains("visible") || name.contains("valid") {
                    match field_type.to_lowercase().as_str() {
                        "bool" | "boolean" => "Boolean flag".to_string(),
                        _ => format!("Boolean indicator ({})", field_type),
                    }
                }
                // Array patterns
                else if name.ends_with("s") && (field_type.contains("[]") || field_type.contains("Array") || 
                        field_type.contains("Vec") || field_type.contains("List")) {
                    let singular = if name.ends_with("ies") {
                        name.replace("ies", "y")
                    } else if name.ends_with("es") && name.len() > 3 {
                        name[..name.len()-2].to_string()
                    } else if name.ends_with("s") && name.len() > 1 {
                        name[..name.len()-1].to_string()
                    } else {
                        name.clone()
                    };
                    format!("Array of {} items", singular.replace('_', " "))
                }
                // Default based on type
                else {
                    match field_type.to_lowercase().as_str() {
                        "string" | "str" => format!("Text value ({})", json_name.replace('_', " ")),
                        "int" | "integer" | "i32" | "i64" | "int64" | "number" => format!("Numeric value ({})", json_name.replace('_', " ")),
                        "float" | "double" | "f32" | "f64" | "float64" => format!("Decimal value ({})", json_name.replace('_', " ")),
                        "bool" | "boolean" => format!("Boolean value ({})", json_name.replace('_', " ")),
                        _ => format!("Field of type {} ({})", field_type, json_name.replace('_', " ")),
                    }
                }
            }
        }
    }
    
    /// Generate current timestamp for file headers
    pub fn current_timestamp() -> chrono::DateTime<chrono::Utc> {
        chrono::Utc::now()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    #[test]
    fn test_go_comment_generator() {
        let generator = GoCommentGenerator;
        let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
        
        let header = generator.generate_file_header("j2s", &timestamp);
        assert!(header.contains("Code generated by j2s"));
        assert!(header.contains("2023-12-25 10:30:00 UTC"));
        
        let struct_comment = generator.generate_struct_comment("User", Some("User information"));
        assert_eq!(struct_comment, "// User User information\n");
        
        let field_comment = generator.generate_field_comment("name", "string", None);
        assert_eq!(field_comment, "\t// name is of type string\n");
    }
    
    #[test]
    fn test_rust_comment_generator() {
        let generator = RustCommentGenerator;
        let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
        
        let header = generator.generate_file_header("j2s", &timestamp);
        assert!(header.contains("//! Code generated by j2s"));
        
        let struct_comment = generator.generate_struct_comment("User", None);
        assert!(struct_comment.contains("/// User represents"));
    }
    
    #[test]
    fn test_typescript_comment_generator() {
        let generator = TypeScriptCommentGenerator;
        let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
        
        let header = generator.generate_file_header("j2s", &timestamp);
        assert!(header.contains("/**"));
        assert!(header.contains("Code generated by j2s"));
        assert!(header.contains("*/"));
        
        let multi_line = generator.generate_multi_line_comment(&["Line 1", "Line 2"]);
        assert!(multi_line.contains("/**"));
        assert!(multi_line.contains(" * Line 1"));
        assert!(multi_line.contains(" * Line 2"));
        assert!(multi_line.contains(" */"));
    }
    
    #[test]
    fn test_python_comment_generator() {
        let generator = PythonCommentGenerator;
        let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
        
        let header = generator.generate_file_header("j2s", &timestamp);
        assert!(header.contains("\"\"\"Code generated by j2s"));
        
        let struct_comment = generator.generate_struct_comment("User", Some("User data"));
        assert!(struct_comment.contains("\"\"\"User - User data\"\"\""));
    }
    
    #[test]
    fn test_comment_generator_factory() {
        let go_gen = CommentGeneratorFactory::create_generator("go");
        assert_eq!(go_gen.language_name(), "Go");
        
        let rust_gen = CommentGeneratorFactory::create_generator("rust");
        assert_eq!(rust_gen.language_name(), "Rust");
        
        let ts_gen = CommentGeneratorFactory::create_generator("typescript");
        assert_eq!(ts_gen.language_name(), "TypeScript");
        
        let py_gen = CommentGeneratorFactory::create_generator("python");
        assert_eq!(py_gen.language_name(), "Python");
        
        // Test fallback
        let unknown_gen = CommentGeneratorFactory::create_generator("unknown");
        assert_eq!(unknown_gen.language_name(), "Go");
    }
    
    #[test]
    fn test_escape_comment_text() {
        let text = "This has */ and <!-- --> in it";
        let escaped = utils::escape_comment_text(text);
        assert_eq!(escaped, "This has * / and &lt;!-- --&gt; in it");
    }
    
    #[test]
    fn test_infer_field_description() {
        assert_eq!(utils::infer_field_description("user_id", "int"), "Unique identifier for the user");
        assert_eq!(utils::infer_field_description("name", "string"), "Name or title");
        assert_eq!(utils::infer_field_description("email", "string"), "Email address");
        assert_eq!(utils::infer_field_description("unknown_field", "bool"), "Field of type bool");
    }
    
    #[test]
    fn test_supported_languages() {
        let languages = CommentGeneratorFactory::supported_languages();
        assert!(languages.contains(&"go"));
        assert!(languages.contains(&"rust"));
        assert!(languages.contains(&"typescript"));
        assert!(languages.contains(&"python"));
    }
}