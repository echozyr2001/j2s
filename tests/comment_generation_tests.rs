//! Unit tests for the comment generation system
//!
//! This module contains comprehensive tests for the comment generation functionality,
//! including tests for all supported languages and edge cases.

use json2schema::codegen::comments::{
    CommentGenerator, CommentGeneratorFactory, GoCommentGenerator, RustCommentGenerator,
    TypeScriptCommentGenerator, PythonCommentGenerator,
};
use chrono::{TimeZone, Utc};

#[test]
fn test_go_comment_generation() {
    let generator = GoCommentGenerator;
    let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
    
    // Test file header
    let header = generator.generate_file_header("j2s", &timestamp);
    assert!(header.contains("Code generated by j2s"));
    assert!(header.contains("2023-12-25 10:30:00 UTC"));
    assert!(header.contains("DO NOT EDIT"));
    
    // Test struct comment with description
    let struct_comment = generator.generate_struct_comment("User", Some("User information"));
    assert_eq!(struct_comment, "// User User information\n");
    
    // Test struct comment without description
    let struct_comment_auto = generator.generate_struct_comment("User", None);
    assert!(struct_comment_auto.contains("User represents the structure"));
    
    // Test field comment with description
    let field_comment = generator.generate_field_comment("name", "string", Some("User's full name"));
    assert_eq!(field_comment, "\t// name (string): User's full name\n");
    
    // Test field comment without description
    let field_comment_auto = generator.generate_field_comment("name", "string", None);
    assert_eq!(field_comment_auto, "\t// name is of type string\n");
    
    // Test single line comment
    let single_line = generator.generate_single_line_comment("This is a comment");
    assert_eq!(single_line, "// This is a comment\n");
    
    // Test multi-line comment
    let multi_line = generator.generate_multi_line_comment(&["Line 1", "Line 2"]);
    assert_eq!(multi_line, "// Line 1\n// Line 2\n");
}

#[test]
fn test_rust_comment_generation() {
    let generator = RustCommentGenerator;
    let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
    
    // Test file header
    let header = generator.generate_file_header("j2s", &timestamp);
    assert!(header.contains("//! Code generated by j2s"));
    assert!(header.contains("2023-12-25 10:30:00 UTC"));
    assert!(header.contains("DO NOT EDIT"));
    assert!(header.ends_with("\n\n"));
    
    // Test struct comment with description
    let struct_comment = generator.generate_struct_comment("User", Some("User information"));
    assert_eq!(struct_comment, "/// User - User information\n");
    
    // Test struct comment without description
    let struct_comment_auto = generator.generate_struct_comment("User", None);
    assert!(struct_comment_auto.contains("/// User represents the structure"));
    
    // Test field comment with description
    let field_comment = generator.generate_field_comment("name", "String", Some("User's full name"));
    assert_eq!(field_comment, "    /// name (String): User's full name\n");
    
    // Test field comment without description
    let field_comment_auto = generator.generate_field_comment("name", "String", None);
    assert_eq!(field_comment_auto, "    /// name is of type String\n");
    
    // Test single line comment
    let single_line = generator.generate_single_line_comment("This is a comment");
    assert_eq!(single_line, "/// This is a comment\n");
    
    // Test multi-line comment
    let multi_line = generator.generate_multi_line_comment(&["Line 1", "Line 2"]);
    assert_eq!(multi_line, "/// Line 1\n/// Line 2\n");
}

#[test]
fn test_typescript_comment_generation() {
    let generator = TypeScriptCommentGenerator;
    let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
    
    // Test file header
    let header = generator.generate_file_header("j2s", &timestamp);
    assert!(header.contains("/**"));
    assert!(header.contains("Code generated by j2s"));
    assert!(header.contains("2023-12-25 10:30:00 UTC"));
    assert!(header.contains("DO NOT EDIT"));
    assert!(header.contains("*/"));
    assert!(header.ends_with("\n\n"));
    
    // Test struct comment with description
    let struct_comment = generator.generate_struct_comment("User", Some("User information"));
    assert_eq!(struct_comment, "/**\n * User - User information\n */\n");
    
    // Test struct comment without description
    let struct_comment_auto = generator.generate_struct_comment("User", None);
    assert!(struct_comment_auto.contains("/**"));
    assert!(struct_comment_auto.contains("User represents the structure"));
    assert!(struct_comment_auto.contains("*/"));
    
    // Test field comment with description
    let field_comment = generator.generate_field_comment("name", "string", Some("User's full name"));
    assert_eq!(field_comment, "  /** name (string): User's full name */\n");
    
    // Test field comment without description
    let field_comment_auto = generator.generate_field_comment("name", "string", None);
    assert_eq!(field_comment_auto, "  /** name is of type string */\n");
    
    // Test single line comment
    let single_line = generator.generate_single_line_comment("This is a comment");
    assert_eq!(single_line, "// This is a comment\n");
    
    // Test multi-line comment
    let multi_line = generator.generate_multi_line_comment(&["Line 1", "Line 2"]);
    assert_eq!(multi_line, "/**\n * Line 1\n * Line 2\n */\n");
}

#[test]
fn test_python_comment_generation() {
    let generator = PythonCommentGenerator;
    let timestamp = Utc.with_ymd_and_hms(2023, 12, 25, 10, 30, 0).unwrap();
    
    // Test file header
    let header = generator.generate_file_header("j2s", &timestamp);
    assert!(header.contains("\"\"\"Code generated by j2s"));
    assert!(header.contains("2023-12-25 10:30:00 UTC"));
    assert!(header.contains("DO NOT EDIT"));
    assert!(header.contains("\"\"\""));
    assert!(header.ends_with("\n\n"));
    
    // Test struct comment with description
    let struct_comment = generator.generate_struct_comment("User", Some("User information"));
    assert_eq!(struct_comment, "    \"\"\"User - User information\"\"\"\n");
    
    // Test struct comment without description
    let struct_comment_auto = generator.generate_struct_comment("User", None);
    assert!(struct_comment_auto.contains("\"\"\"User"));
    assert!(struct_comment_auto.contains("Represents the structure"));
    assert!(struct_comment_auto.contains("\"\"\""));
    
    // Test field comment with description
    let field_comment = generator.generate_field_comment("name", "str", Some("User's full name"));
    assert_eq!(field_comment, "    # name (str): User's full name\n");
    
    // Test field comment without description
    let field_comment_auto = generator.generate_field_comment("name", "str", None);
    assert_eq!(field_comment_auto, "    # name is of type str\n");
    
    // Test single line comment
    let single_line = generator.generate_single_line_comment("This is a comment");
    assert_eq!(single_line, "# This is a comment\n");
    
    // Test multi-line comment
    let multi_line = generator.generate_multi_line_comment(&["Line 1", "Line 2"]);
    assert_eq!(multi_line, "\"\"\"Line 1\nLine 2\n\"\"\"\n");
}

#[test]
fn test_comment_generator_factory() {
    // Test Go generator creation
    let go_gen = CommentGeneratorFactory::create_generator("go");
    assert_eq!(go_gen.language_name(), "Go");
    
    // Test Rust generator creation
    let rust_gen = CommentGeneratorFactory::create_generator("rust");
    assert_eq!(rust_gen.language_name(), "Rust");
    
    // Test TypeScript generator creation
    let ts_gen = CommentGeneratorFactory::create_generator("typescript");
    assert_eq!(ts_gen.language_name(), "TypeScript");
    
    let ts_gen_short = CommentGeneratorFactory::create_generator("ts");
    assert_eq!(ts_gen_short.language_name(), "TypeScript");
    
    // Test Python generator creation
    let py_gen = CommentGeneratorFactory::create_generator("python");
    assert_eq!(py_gen.language_name(), "Python");
    
    let py_gen_short = CommentGeneratorFactory::create_generator("py");
    assert_eq!(py_gen_short.language_name(), "Python");
    
    // Test case insensitive
    let go_gen_upper = CommentGeneratorFactory::create_generator("GO");
    assert_eq!(go_gen_upper.language_name(), "Go");
    
    // Test fallback to Go for unknown languages
    let unknown_gen = CommentGeneratorFactory::create_generator("unknown");
    assert_eq!(unknown_gen.language_name(), "Go");
}

#[test]
fn test_supported_languages() {
    let languages = CommentGeneratorFactory::supported_languages();
    assert_eq!(languages.len(), 4);
    assert!(languages.contains(&"go"));
    assert!(languages.contains(&"rust"));
    assert!(languages.contains(&"typescript"));
    assert!(languages.contains(&"python"));
}

#[test]
fn test_comment_escaping() {
    use json2schema::codegen::comments::utils::escape_comment_text;
    
    // Test basic escaping
    let text = "This has */ and <!-- --> in it";
    let escaped = escape_comment_text(text);
    assert_eq!(escaped, "This has * / and &lt;!-- --&gt; in it");
    
    // Test no escaping needed
    let clean_text = "This is a clean comment";
    let escaped_clean = escape_comment_text(clean_text);
    assert_eq!(escaped_clean, "This is a clean comment");
    
    // Test multiple occurrences
    let multi_text = "/* comment */ and <!-- another --> and */";
    let escaped_multi = escape_comment_text(multi_text);
    assert_eq!(escaped_multi, "/* comment * / and &lt;!-- another --&gt; and * /");
}

#[test]
fn test_field_description_inference() {
    use json2schema::codegen::comments::utils::infer_field_description;
    
    // Test ID fields
    assert_eq!(infer_field_description("user_id", "int"), "Unique identifier for the user");
    assert_eq!(infer_field_description("id", "int"), "Unique identifier");
    assert_eq!(infer_field_description("product_id", "string"), "Unique identifier for the product");
    
    // Test name fields
    assert_eq!(infer_field_description("name", "string"), "Name or title");
    assert_eq!(infer_field_description("user_name", "string"), "Name or title");
    assert_eq!(infer_field_description("full_name", "string"), "Name or title");
    
    // Test email fields
    assert_eq!(infer_field_description("email", "string"), "Email address");
    assert_eq!(infer_field_description("email_address", "string"), "Email address");
    
    // Test phone fields
    assert_eq!(infer_field_description("phone", "string"), "Phone number");
    assert_eq!(infer_field_description("phone_number", "string"), "Phone number");
    
    // Test address fields
    assert_eq!(infer_field_description("address", "string"), "Address information");
    assert_eq!(infer_field_description("home_address", "string"), "Address information");
    
    // Test date/time fields
    assert_eq!(infer_field_description("created_date", "string"), "Date/time value");
    assert_eq!(infer_field_description("date", "string"), "Date/time value");
    assert_eq!(infer_field_description("timestamp", "string"), "Date/time value");
    
    // Test URL fields
    assert_eq!(infer_field_description("url", "string"), "URL or link");
    assert_eq!(infer_field_description("website_link", "string"), "URL or link");
    
    // Test count fields
    assert_eq!(infer_field_description("count", "int"), "Count or total value");
    assert_eq!(infer_field_description("total_count", "int"), "Count or total value");
    
    // Test status fields
    assert_eq!(infer_field_description("status", "string"), "Status indicator");
    assert_eq!(infer_field_description("user_status", "string"), "Status indicator");
    
    // Test type fields
    assert_eq!(infer_field_description("type", "string"), "Type classification");
    assert_eq!(infer_field_description("content_type", "string"), "Type classification");
    
    // Test boolean fields
    assert_eq!(infer_field_description("is_active", "bool"), "Boolean flag");
    assert_eq!(infer_field_description("has_permission", "bool"), "Boolean flag");
    assert_eq!(infer_field_description("enabled", "bool"), "Boolean flag");
    
    // Test array fields
    assert_eq!(infer_field_description("items", "Vec<String>"), "Array of item items");
    assert_eq!(infer_field_description("categories", "Array<String>"), "Array of category items");
    
    // Test enhanced type-based descriptions
    assert_eq!(infer_field_description("custom_field", "string"), "Text value (custom field)");
    assert_eq!(infer_field_description("score", "int"), "Numeric value (score)");
    assert_eq!(infer_field_description("unknown_field", "bool"), "Boolean value (unknown field)");
}

#[test]
fn test_current_timestamp() {
    use json2schema::codegen::comments::utils::current_timestamp;
    
    let timestamp = current_timestamp();
    
    // Just verify it's a valid timestamp (not testing exact time)
    assert!(timestamp.timestamp() > 0);
    
    // Test that it formats correctly
    let formatted = timestamp.format("%Y-%m-%d %H:%M:%S UTC").to_string();
    assert!(formatted.contains("UTC"));
    assert!(formatted.len() > 10); // Should be a reasonable length
}

#[test]
fn test_empty_comments() {
    let generator = GoCommentGenerator;
    
    // Test empty field comment
    let empty_field = generator.generate_field_comment("", "string", None);
    assert!(empty_field.contains("is of type string"));
    
    // Test empty struct comment
    let empty_struct = generator.generate_struct_comment("", None);
    assert!(empty_struct.contains("represents the structure"));
}

#[test]
fn test_special_characters_in_comments() {
    let generator = TypeScriptCommentGenerator;
    
    // Test field with special characters
    let special_field = generator.generate_field_comment("field@name", "string", Some("Field with @ symbol"));
    assert!(special_field.contains("field@name"));
    assert!(special_field.contains("Field with @ symbol"));
    
    // Test struct with special characters
    let special_struct = generator.generate_struct_comment("User$Data", Some("Data with $ symbol"));
    assert!(special_struct.contains("User$Data"));
    assert!(special_struct.contains("Data with $ symbol"));
}